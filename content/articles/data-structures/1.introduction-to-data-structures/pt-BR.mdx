---
title: Introdução à estruturas de dados
description: Entenda como estruturas de dados transformam bytes aleatórios em padrões significativos. Explore memória contígua vs espalhada, estruturas lineares vs não-lineares, e os tradeoffs que moldam o desempenho do seu código.
slug: introducao-estruturas-de-dados
keywords:
  [
    estruturas de dados,
    fundamentos,
    memória contígua,
    memória espalhada,
    arrays,
    linked lists,
    complexidade,
    tipos abstratos de dados,
    ADT,
    organização de memória,
  ]
---

## TADs vs Estruturas de dados

É importante entender dois conceitos fundamentais que muitas vezes se confundem:

### Tipos abstratos de dados (TADs)

Definem **o quê** você pode fazer - quais operações existem e seu comportamento esperado. É o contrato da interface, a especificação abstrata. Um TAD diz "você pode empilhar e desempilhar", mas não diz como isso funciona por baixo dos panos.

### Estruturas de dados

Definem **como** fazer - a implementação concreta na memória. É a realização prática do conceito. Uma estrutura de dados mostra exatamente como os bytes são organizados e manipulados.

<Example title="Exemplo prático">

Uma "stack" (pilha) é um TAD que define comportamento LIFO (Last In, First Out). Você pode implementá-la usando arrays ou linked lists - estruturas de dados diferentes, mesmo comportamento abstrato. A escolha da estrutura afeta performance, mas o TAD permanece o mesmo.

</Example>

## Organização lógica dos dados

A forma como os elementos se relacionam entre si define a natureza fundamental da estrutura:

### Estruturas lineares

Estabelecem uma ordem sequencial clara - existe um primeiro elemento, um último, e todos os intermediários possuem exatamente um predecessor e um sucessor. É como uma fila de pessoas: você sabe quem está à sua frente e quem está atrás.

<Example title="Exemplos de estruturas lineares">

**Arrays, linked lists, stacks e queues** são exemplos clássicos. Em uma stack (pilha), você empilha pratos um sobre o outro - só acessa o do topo. Em uma queue (fila), é como uma fila de banco - quem chega primeiro é atendido primeiro. A linearidade está na relação entre elementos, não necessariamente na disposição física.

</Example>

### Estruturas não-lineares

Quebram essa sequencialidade única. Aqui, um elemento pode se conectar a vários outros simultaneamente, formando hierarquias ou redes complexas. Como uma árvore genealógica ou rede social.

<Example title="Exemplos de estruturas não-lineares">

**Trees (árvores)** organizam dados hierarquicamente - como pastas e arquivos no seu computador. **Graphs (grafos)** representam redes arbitrárias - como rotas entre cidades ou conexões em redes sociais. **Hash tables** usam funções matemáticas para espalhar dados e acessá-los instantaneamente, como um índice de livro turbinado.

</Example>

## Perspectiva de memória

Além da organização lógica, existe a questão física: como os bytes são dispostos na memória RAM?

### Memória contígua

Elementos armazenados em posições adjacentes e sequenciais na memória. Como uma rua com casas numeradas sequencialmente.

<MemoryVisualization
  title="Memória RAM:"
  type="contiguous"
  blocks={[
    { address: '0x1000', value: 42, label: 'índice 0' },
    { address: '0x1004', value: 17, label: 'índice 1' },
    { address: '0x1008', value: 93, label: 'índice 2' },
    { address: '0x100C', value: 28, label: 'índice 3' },
  ]}
>
  <span className="text-danger">Array:</span>{' '}
  <span className="text-warning">[</span>
  <span className="text-success">42, 17, 93, 28</span>
  <span className="text-warning">]</span>
</MemoryVisualization>

Arrays funcionam assim. Cada elemento ocupa 4 bytes, então o elemento `array[2]` está matematicamente em `endereço_base + (2 × 4)`. Acesso instantâneo O(1)! Mas inserir no meio? Precisa deslocar todos os elementos seguintes - imagine reorganizar uma estante de livros inteira porque você quer inserir um no meio.

### Memória não-contígua

Elementos espalhados em diferentes regiões da memória, conectados por ponteiros. Como uma caça ao tesouro onde cada pista aponta para a próxima.

<MemoryVisualization
  title="Memória RAM (espalhada):"
  type="linked"
  blocks={[
    { address: '0x1000', value: 'dados: 10', nextAddress: '0x5FA0' },
    { address: '0x5FA0', value: 'dados: 20', nextAddress: '0x2C10' },
    { address: '0x2C10', value: 'dados: 30', nextAddress: 'NULL' },
  ]}
>
  <span className="text-danger">Linked List:</span>{' '}
  <span className="text-success">10</span>{' '}
  <span className="text-primary">→</span>{' '}
  <span className="text-success">20</span>{' '}
  <span className="text-primary">→</span>{' '}
  <span className="text-success">30</span>
</MemoryVisualization>

Linked lists funcionam assim. Cada nó carrega seu dado e um ponteiro para o próximo. Inserir no meio? Fácil - apenas redirecione dois ponteiros. Mas acessar o elemento 100? Precisa seguir 100 pistas sequencialmente - O(n).

## O que as torna diferentes

Cada estrutura de dados faz tradeoffs:

- **Layout de memória** - Contígua (arrays) vs espalhada (linked lists)
- **Padrões de acesso** - Acesso aleatório vs travessia sequencial
- **Custos de operação** - Inserções rápidas mas buscas lentas, ou vice-versa
- **Overhead de espaço** - Metadados mínimos vs estruturas pesadas em ponteiros

A escolha certa depende do seu caso de uso específico. Precisa de buscas rápidas? Hash tables. Manter ordem? Binary search trees. Comportamento LIFO? Stacks.
