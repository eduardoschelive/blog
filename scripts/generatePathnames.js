import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const PRIMARY_LANGUAGE = 'en-US'
const LANGUAGES = ['en-US', 'pt-BR']

const ROUTE_MAPPING = {
  'en-US': {
    categories: 'categories',
    articles: 'articles',
  },
  'pt-BR': {
    categories: 'categorias',
    articles: 'artigos',
  },
}

const PATHS = {
  categories: ['content', 'categories'],
  articles: ['content', 'articles'],
  output: ['generated', 'pathnames.ts'],
}

function joinPath(parts) {
  return path.join(process.cwd(), ...parts)
}

function getCategoryDirectories() {
  const categoriesDir = joinPath(PATHS.categories)
  return fs
    .readdirSync(categoriesDir, { withFileTypes: true })
    .filter(
      (dirent) => dirent.isDirectory() && !LANGUAGES.includes(dirent.name)
    )
    .map((dirent) => dirent.name)
}

function getArticleDirectories(categorySlug) {
  const articlesDir = joinPath([...PATHS.articles, categorySlug])
  if (!fs.existsSync(articlesDir)) return []

  return fs
    .readdirSync(articlesDir, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name)
}

function removeSequencePrefix(slug) {
  return slug.replace(/^\d+\./, '')
}

function getFrontmatter(filePath) {
  if (!fs.existsSync(filePath)) return null

  const content = fs.readFileSync(filePath, 'utf-8')
  const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---/)

  if (!frontmatterMatch) return null

  const frontmatter = {}
  const lines = frontmatterMatch[1].split('\n')

  for (const line of lines) {
    const [key, ...valueParts] = line.split(':')
    if (key && valueParts.length > 0) {
      const value = valueParts.join(':').trim()
      frontmatter[key.trim()] = value.replace(/^['"]|['"]$/g, '')
    }
  }

  return frontmatter
}

function generatePathnames() {
  const generatedPathNames = {}

  const categories = getCategoryDirectories()

  for (const categorySlug of categories) {
    const categoryPaths = {}

    for (const locale of LANGUAGES) {
      const categoryFilePath = joinPath([
        ...PATHS.categories,
        categorySlug,
        locale + '.mdx',
      ])

      const frontmatter = getFrontmatter(categoryFilePath)
      const routePrefix = ROUTE_MAPPING[locale].categories
      const slug = frontmatter?.slug || categorySlug
      categoryPaths[locale] = `/${routePrefix}/${slug}`
    }

    if (LANGUAGES.every((lang) => categoryPaths[lang])) {
      // Usar o idioma primÃ¡rio como chave, mas sÃ³ incluir outros idiomas no objeto
      const primaryRoute = categoryPaths[PRIMARY_LANGUAGE]
      const otherLanguages = {}

      LANGUAGES.forEach((lang) => {
        if (lang !== PRIMARY_LANGUAGE) {
          otherLanguages[lang] = categoryPaths[lang]
        }
      })

      generatedPathNames[primaryRoute] = otherLanguages
    }

    const articles = getArticleDirectories(categorySlug)

    for (const articleSlug of articles) {
      const articlePaths = {}

      for (const locale of LANGUAGES) {
        const articleFilePath = joinPath([
          ...PATHS.articles,
          categorySlug,
          articleSlug,
          locale + '.mdx',
        ])

        const frontmatter = getFrontmatter(articleFilePath)
        const articleRoutePrefix = ROUTE_MAPPING[locale].articles
          =
        const cleanSlug = removeSequencePrefix(frontmatter?.slug || articleSlug)
        articlePaths[locale] =
          `${categoryPaths[locale]}/${articleRoutePrefix}/${cleanSlug}`
      }

      if (LANGUAGES.every((lang) => articlePaths[lang])) {
        const primaryRoute = articlePaths[PRIMARY_LANGUAGE]
        const otherLanguages = {}

        LANGUAGES.forEach((lang) => {
          if (lang !== PRIMARY_LANGUAGE) {
            otherLanguages[lang] = articlePaths[lang]
          }
        })

        generatedPathNames[primaryRoute] = otherLanguages
      }
    }
  }

  return generatedPathNames
}

function main() {
  console.log('ðŸš€ Generating pathnames...')

  const generatedPathNames = generatePathnames()

  const outputPath = joinPath(PATHS.output)
  const outputDir = path.dirname(outputPath)

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  const formatObject = (obj, indent = 0) => {
    const spaces = '  '.repeat(indent)
    const nextSpaces = '  '.repeat(indent + 1)

    if (typeof obj !== 'object' || obj === null) {
      return `'${obj}'`
    }

    const entries = Object.entries(obj)
    if (entries.length === 0) return '{}'

    const formatted = entries
      .map(([key, value]) => {
        return `${nextSpaces}'${key}': ${formatObject(value, indent + 1)},`
      })
      .join('\n')

    return `{\n${formatted}\n${spaces}}`
  }

  const pathnamesString = formatObject(generatedPathNames)

  const content = `// This file is auto-generated by the generatePathnames.js script
// Do not edit this file manually

export const generatedPathnames = ${pathnamesString} as const
`

  fs.writeFileSync(outputPath, content)
  console.log('âœ… Pathnames generated at: ' + outputPath)
  console.log('ðŸ“Š Total routes: ' + Object.keys(generatedPathNames).length)
}

main()
